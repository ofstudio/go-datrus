// Генератор справочника кодов счетов первого и второго порядка.
// См Положение №385-П ЦБ РФ "О правилах ведения бухгалтерского учета
// в кредитных организациях, расположенных на территории Российской Федерации".
//
// https://cbr.ru/Queries/UniDbQuery/File/85920?fileId=-1&scope=1374-1375
//
// Требования к входному файлу:
//  1. Текстовый файл в кодировке UTF-8, разделители: символы табуляции.
//  2. Первая строка содержит дату актуальности данных в формате: "# YYYY-MM-DD"
//  3. Каждая последующая строка содержит информацию о счете первого или второго порядка.
//  4. Строка со счетом должна начинаться с 3 или 5 цифр кода.
//     Наименование счета отделяется от кода одним или несколькими символам табуляции.
//     После наименования может следовать или конец строки,
//     или символ табуляции и другие поля (будут проигнорированы).
//  6. Строки, не соответствующие счетам, будут проигнорированы
//
// Примеры исходных данных для формирования входного файла:
//
//  1. https://www.consultant.ru/document/cons_doc_LAW_3759/attach_LAW_129526_2/
//  2. https://www.profbanking.com/chart-of-accounts-in-banks
package main

import (
	"bufio"
	"flag"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"
	"time"
)

type Dict struct {
	DataDate    string
	GenDateTime string
	Items       []DictItem
}

type DictItem struct {
	Id    string
	Title string
}

var reItem *regexp.Regexp

func init() {
	reItem = regexp.MustCompile(`^(\d{3,5})\t+([^\t]*)\t*.*$`)
}

func main() {
	inFilename := flag.String("in", "", "Путь к входному файлу")
	outFilename := flag.String("out", "", "Путь к генерируемому файлу")
	flag.Parse()
	if *inFilename == "" || *outFilename == "" {
		flag.Usage()
		os.Exit(-1)
	}

	inFile, err := os.Open(*inFilename)
	if err != nil {
		log.Fatal(err)
	}
	outFile, err := os.Create(*outFilename)
	if err != nil {
		log.Fatal(err)
	}
	//goland:noinspection ALL
	defer outFile.Close()

	// read file
	scanner := bufio.NewScanner(inFile)
	total, ignored := 0, 0

	// read first line - DataDate
	scanner.Scan()
	dict := Dict{
		DataDate:    strings.TrimPrefix(scanner.Text(), "# "),
		GenDateTime: time.Now().Format(time.RFC1123),
	}

	// read rest of file
	for scanner.Scan() {
		total++
		matches := reItem.FindStringSubmatch(scanner.Text())
		if len(matches) != 3 {
			ignored++
			continue
		}
		dict.Items = append(dict.Items, DictItem{
			Id:    matches[1],
			Title: escape(matches[2]),
		})
	}
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	log.Printf("Успешно прочитан файл %s", *inFilename)
	log.Print("Дата актуализации: ", dict.DataDate)
	log.Print("Всего строк: ", total+1)
	log.Print("Проигнорировано строк: ", ignored+1)
	log.Print("Всего кодов счетов: ", len(dict.Items))

	t := template.Must(template.New("queue").Parse(dictTemplate))
	if err = t.Execute(outFile, dict); err != nil {
		log.Fatal(err)
	}

	log.Printf("Успешно сгенерирован файл %s", *outFilename)
}

func escape(s string) string {
	return strings.Replace(s, `"`, `\"`, -1)
}

const dictTemplate = `// Code generated by dict-account-code-gen. DO NOT EDIT.
// Generated at: {{.GenDateTime}}

package dict

// accountDict - справочник кодов счетов согласно Положению №385-П ЦБ РФ
// "О правилах ведения бухгалтерского учета в кредитных организациях, расположенных на территории Российской Федерации".
//
// Источники:
//   - https://cbr.ru/Queries/UniDbQuery/File/85920?fileId=-1&scope=1374-1375
//   - https://www.profbanking.com/chart-of-accounts-in-banks
//
// Всего кодов: {{ len .Items }}.
// Актуальность справочника: {{.DataDate}}.
var accountDict = map[string]string{
{{- range .Items}}
	"{{.Id}}": "{{.Title}}",
{{- end}}
}
`
